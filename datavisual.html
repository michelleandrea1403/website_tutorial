<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1인 가구 데이터 시각화</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f5f5f0;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const SingleHouseholdVisualization = () => {
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const [isRotating, setIsRotating] = useState(true);
            const [selectedYear, setSelectedYear] = useState(2024);
            const [isAnimating, setIsAnimating] = useState(false);
            const [hoveredParticle, setHoveredParticle] = useState(null);
            const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });

            // 시계열 데이터 (파티클 수를 더 극적으로)
            const timelineData = [
                { year: 1990, total: 257000, ratio: 9.1, particleMultiplier: 0.3 },
                { year: 1995, total: 382000, ratio: 12.7, particleMultiplier: 0.5 },
                { year: 2000, total: 502000, ratio: 16.3, particleMultiplier: 0.65 },
                { year: 2005, total: 675000, ratio: 20.2, particleMultiplier: 0.8 },
                { year: 2010, total: 854606, ratio: 23.9, particleMultiplier: 1.0 },
                { year: 2015, total: 1116000, ratio: 29.5, particleMultiplier: 1.4 },
                { year: 2020, total: 1390701, ratio: 34.2, particleMultiplier: 1.8 },
                { year: 2024, total: 1660813, ratio: 39.3, particleMultiplier: 2.2 }
            ];

            // 2024년 연령대별 데이터 (기준)
            const ageGroupBase = [
                { age: '20세미만', count: 11594, color: 0xff6b6b, ratio: 0.007 },
                { age: '20-24세', count: 128843, color: 0xff8787, ratio: 0.078 },
                { age: '25-29세', count: 281863, color: 0xffa07a, ratio: 0.170 },
                { age: '30-34세', count: 252180, color: 0xffb84d, ratio: 0.152 },
                { age: '35-39세', count: 141374, color: 0xffd93d, ratio: 0.085 },
                { age: '40-44세', count: 109595, color: 0xf4e04d, ratio: 0.066 },
                { age: '45-49세', count: 86296, color: 0xa8e6cf, ratio: 0.052 },
                { age: '50-54세', count: 96342, color: 0x7bcfa6, ratio: 0.058 },
                { age: '55-59세', count: 91215, color: 0x4ecdc4, ratio: 0.055 },
                { age: '60-64세', count: 105325, color: 0x3da9fc, ratio: 0.063 },
                { age: '65-69세', count: 110955, color: 0x6a89cc, ratio: 0.067 },
                { age: '70-74세', count: 81462, color: 0x8e7cc3, ratio: 0.049 },
                { age: '75-79세', count: 69728, color: 0xb392ac, ratio: 0.042 },
                { age: '80-84세', count: 53509, color: 0xd896ad, ratio: 0.032 },
                { age: '85세이상', count: 40532, color: 0xf7a4a4, ratio: 0.024 }
            ];

            // 연령대별 주요 이유 매핑
            const ageReasonMapping = {
                '20세미만': '본인의 학업·직장',
                '20-24세': '본인의 학업·직장',
                '25-29세': '본인의 학업·직장',
                '30-34세': '본인의 학업·직장',
                '35-39세': '본인의 학업·직장',
                '40-44세': '본인의 학업·직장',
                '45-49세': '혼자 살고 싶어서',
                '50-54세': '본인의 이혼',
                '55-59세': '본인의 이혼',
                '60-64세': '배우자의 사망',
                '65-69세': '배우자의 사망',
                '70-74세': '배우자의 사망',
                '75-79세': '배우자의 사망',
                '80-84세': '배우자의 사망',
                '85세이상': '배우자의 사망'
            };

            // 중심 이유 카테고리
            const reasonCategories = [
                { name: '배우자의 사망', percent: 31.9, color: 0xff6b6b },
                { name: '본인의 학업·직장', percent: 22.4, color: 0x4ecdc4 },
                { name: '혼자 살고 싶어서', percent: 14.3, color: 0xffe66d },
                { name: '본인의 이혼', percent: 13.7, color: 0xffa07a },
                { name: '가족과 지내는 것이 불편해서', percent: 5.1, color: 0xa8e6cf }
            ];

            // 선택된 연도의 데이터 계산
            const getCurrentYearData = () => {
                const yearData = timelineData.find(d => d.year === selectedYear);
                if (!yearData) return ageGroupBase;
                
                return ageGroupBase.map(age => ({
                    ...age,
                    count: Math.floor(yearData.total * age.ratio),
                    multiplier: yearData.particleMultiplier
                }));
            };

            useEffect(() => {
                if (!containerRef.current) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf5f5f0);
                scene.fog = new THREE.Fog(0xf5f5f0, 30, 60);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(
                    75,
                    containerRef.current.clientWidth / containerRef.current.clientHeight,
                    0.1,
                    1000
                );
                // Initialize camera with spherical coordinates for rotation
                let cameraSpherical = {
                    radius: 40,
                    theta: Math.PI / 2, // horizontal angle
                    phi: Math.PI / 3   // vertical angle
                };
                camera.position.set(
                    cameraSpherical.radius * Math.sin(cameraSpherical.phi) * Math.cos(cameraSpherical.theta),
                    cameraSpherical.radius * Math.cos(cameraSpherical.phi),
                    cameraSpherical.radius * Math.sin(cameraSpherical.phi) * Math.sin(cameraSpherical.theta)
                );
                camera.lookAt(0, 0, 0);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
                containerRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // 중심 노드 그룹
                const centerGroup = new THREE.Group();
                const reasonNodes = [];
                
                reasonCategories.forEach((reason, i) => {
                    const angle = (i / reasonCategories.length) * Math.PI * 2;
                    const radius = 6;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    const geometry = new THREE.SphereGeometry(0.6, 24, 24);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: reason.color,
                        transparent: true,
                        opacity: 0.85
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(x, 0, z);
                    centerGroup.add(sphere);
                    reasonNodes.push({ mesh: sphere, data: reason });

                    const lineGeo = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(x, 0, z)
                    ]);
                    const lineMat = new THREE.LineBasicMaterial({ 
                        color: reason.color,
                        transparent: true,
                        opacity: 0.4
                    });
                    const line = new THREE.Line(lineGeo, lineMat);
                    centerGroup.add(line);
                });
                scene.add(centerGroup);

                // 파티클 생성 함수
                let allParticles = [];
                let allLines = [];
                
                const createParticles = (ageData) => {
                    // 기존 파티클 제거
                    allParticles.forEach(p => scene.remove(p));
                    allLines.forEach(l => scene.remove(l));
                    allParticles = [];
                    allLines = [];

                    const yearData = timelineData.find(d => d.year === selectedYear);
                    const multiplier = yearData?.particleMultiplier || 1;

                    ageData.forEach((ageInfo, ageIndex) => {
                        // 극적인 변화를 위해 파티클 수를 multiplier로 조정
                        const baseParticleCount = Math.floor(ageInfo.count / 8000);
                        const particleCount = Math.max(2, Math.floor(baseParticleCount * multiplier));
                        
                        for (let i = 0; i < particleCount; i++) {
                            const baseAngle = (ageIndex / ageData.length) * Math.PI * 2;
                            const angleSpread = (Math.PI * 2) / ageData.length * 0.8;
                            const angle = baseAngle + (Math.random() - 0.5) * angleSpread;
                            
                            const radiusMin = 15;
                            const radiusMax = 25;
                            const radius = radiusMin + Math.random() * (radiusMax - radiusMin);
                            
                            const x = Math.cos(angle) * radius;
                            const z = Math.sin(angle) * radius;
                            const y = (Math.random() - 0.5) * 15;

                            const size = 0.12 + Math.random() * 0.12;
                            const geometry = new THREE.SphereGeometry(size, 8, 8);
                            const material = new THREE.MeshBasicMaterial({ 
                                color: ageInfo.color,
                                transparent: true,
                                opacity: 0.75 + Math.random() * 0.2
                            });
                            const particle = new THREE.Mesh(geometry, material);
                            particle.position.set(x, y, z);
                            particle.userData = { 
                                age: ageInfo.age,
                                basePosition: new THREE.Vector3(x, y, z),
                                phase: Math.random() * Math.PI * 2
                            };
                            scene.add(particle);
                            allParticles.push(particle);

                            // 이유 노드와 연결
                            const mainReason = ageReasonMapping[ageInfo.age];
                            const reasonNode = reasonNodes.find(r => r.data.name === mainReason);
                            
                            if (reasonNode && Math.random() > 0.75) {
                                const lineGeo = new THREE.BufferGeometry().setFromPoints([
                                    reasonNode.mesh.position,
                                    new THREE.Vector3(x, y, z)
                                ]);
                                const lineMat = new THREE.LineBasicMaterial({ 
                                    color: ageInfo.color,
                                    transparent: true,
                                    opacity: 0.2
                                });
                                const line = new THREE.Line(lineGeo, lineMat);
                                scene.add(line);
                                allLines.push(line);
                            }

                            // 주변 파티클 연결
                            if (allParticles.length > 0 && Math.random() > 0.88) {
                                const randomIndex = Math.floor(Math.random() * Math.min(5, allParticles.length));
                                const nearParticle = allParticles[allParticles.length - 1 - randomIndex];
                                
                                const distance = particle.position.distanceTo(nearParticle.position);
                                if (distance < 8) {
                                    const lineGeo = new THREE.BufferGeometry().setFromPoints([
                                        particle.position,
                                        nearParticle.position
                                    ]);
                                    const lineMat = new THREE.LineBasicMaterial({ 
                                        color: 0xcccccc,
                                        transparent: true,
                                        opacity: 0.15
                                    });
                                    const line = new THREE.Line(lineGeo, lineMat);
                                    scene.add(line);
                                    allLines.push(line);
                                }
                            }
                        }
                    });
                };

                // 초기 파티클 생성
                createParticles(getCurrentYearData());

                // 애니메이션
                let time = 0;
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);
                    time += 0.01;

                    if (isRotating) {
                        scene.rotation.y += 0.002;
                        centerGroup.rotation.y += 0.008;
                    }

                    allParticles.forEach((particle, i) => {
                        const userData = particle.userData;
                        const phase = userData.phase;
                        
                        particle.position.x = userData.basePosition.x + Math.sin(time + phase) * 0.25;
                        particle.position.y = userData.basePosition.y + Math.cos(time * 0.6 + phase) * 0.4;
                        particle.position.z = userData.basePosition.z + Math.sin(time * 0.4 + phase) * 0.25;
                        
                        const scale = 1 + Math.sin(time * 2 + phase) * 0.15;
                        particle.scale.set(scale, scale, scale);
                    });

                    centerGroup.children.forEach((child, i) => {
                        if (child instanceof THREE.Mesh) {
                            const scale = 1 + Math.sin(time * 2.5 + i * 0.7) * 0.12;
                            child.scale.set(scale, scale, scale);
                        }
                    });

                    renderer.render(scene, camera);
                };
                animate();

                // 연도 변경 시 파티클 재생성
                const recreateParticles = () => {
                    createParticles(getCurrentYearData());
                };

                // Click and drag camera controls
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                
                const handleMouseDown = (event) => {
                    isDragging = true;
                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                    containerRef.current.style.cursor = 'grabbing';
                };

                const handleMouseMove = (event) => {
                    if (!isDragging) return;
                    
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;
                    
                    // Horizontal rotation (theta)
                    cameraSpherical.theta -= deltaX * 0.01;
                    
                    // Vertical rotation (phi) - clamp to prevent flipping
                    cameraSpherical.phi += deltaY * 0.01;
                    cameraSpherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraSpherical.phi));
                    
                    // Update camera position using spherical coordinates
                    camera.position.set(
                        cameraSpherical.radius * Math.sin(cameraSpherical.phi) * Math.cos(cameraSpherical.theta),
                        cameraSpherical.radius * Math.cos(cameraSpherical.phi),
                        cameraSpherical.radius * Math.sin(cameraSpherical.phi) * Math.sin(cameraSpherical.theta)
                    );
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                };

                const handleMouseUp = () => {
                    isDragging = false;
                    containerRef.current.style.cursor = 'grab';
                };

                // Raycaster for particle hover detection
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                const handleParticleHover = (event) => {
                    if (!containerRef.current || isDragging) {
                        setHoveredParticle(null);
                        return;
                    }

                    const rect = containerRef.current.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(allParticles);

                    if (intersects.length > 0) {
                        const intersectedParticle = intersects[0].object;
                        const ageInfo = intersectedParticle.userData.age;
                        const ageData = getCurrentYearData().find(a => a.age === ageInfo);
                        const yearData = timelineData.find(d => d.year === selectedYear);
                        
                        if (ageData && yearData) {
                            setHoveredParticle({
                                age: ageData.age,
                                count: ageData.count,
                                ratio: ((ageData.count / yearData.total) * 100).toFixed(1)
                            });
                            setTooltipPosition({ x: event.clientX, y: event.clientY });
                            containerRef.current.style.cursor = 'pointer';
                        }
                    } else {
                        setHoveredParticle(null);
                        containerRef.current.style.cursor = 'grab';
                    }
                };

                const handleResize = () => {
                    if (!containerRef.current) return;
                    camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
                };

                // Add event listeners
                containerRef.current.addEventListener('mousedown', handleMouseDown);
                containerRef.current.addEventListener('mousemove', handleParticleHover);
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
                window.addEventListener('resize', handleResize);
                
                // Set initial cursor style
                containerRef.current.style.cursor = 'grab';

                // 이벤트 리스너로 연도 변경 감지
                const handleYearChange = () => {
                    recreateParticles();
                };
                window.addEventListener('yearChanged', handleYearChange);

                return () => {
                    cancelAnimationFrame(animationId);
                    if (containerRef.current) {
                        containerRef.current.removeEventListener('mousedown', handleMouseDown);
                        containerRef.current.removeEventListener('mousemove', handleParticleHover);
                    }
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('yearChanged', handleYearChange);
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                    renderer.dispose();
                };
            }, [selectedYear, isRotating]);

            const handleYearChange = (year) => {
                setSelectedYear(year);
                window.dispatchEvent(new Event('yearChanged'));
            };

            const playTimeline = () => {
                setIsAnimating(true);
                let currentIndex = 0;
                const interval = setInterval(() => {
                    if (currentIndex >= timelineData.length) {
                        clearInterval(interval);
                        setIsAnimating(false);
                        return;
                    }
                    handleYearChange(timelineData[currentIndex].year);
                    currentIndex++;
                }, 2000);
            };

            const currentYearData = timelineData.find(d => d.year === selectedYear);
            const currentAgeData = getCurrentYearData();
            const yearData = timelineData.find(d => d.year === selectedYear);
            const multiplier = yearData?.particleMultiplier || 1;
            const totalParticles = currentAgeData.reduce((sum, age) => {
                const baseCount = Math.floor(age.count / 8000);
                return sum + Math.max(2, Math.floor(baseCount * multiplier));
            }, 0);

            return (
                <div className="w-full h-screen relative overflow-hidden" style={{ backgroundColor: '#f5f5f0' }}>
                    <div ref={containerRef} className="w-full h-full" />
                    
                    {/* 헤더 */}
                    <div className="absolute top-8 left-8">
                        <a href="index.html" className="inline-block border border-black px-3 py-1 rounded-full text-xs font-medium mb-4 hover:bg-black hover:text-white transition-colors">
                            SINGLE HOUSEHOLD DATA
                        </a>
                        <h1 className="text-6xl font-light tracking-tight text-black mb-2">
                            1인 가구<br/>증가 추이
                        </h1>
                        <p className="text-lg text-gray-600 font-light">1990-2024 서울시 데이터</p>
                    </div>

                    {/* 타임라인 카드 */}
                    <div className="absolute top-8 right-8 bg-white rounded-2xl shadow-lg p-6 max-w-sm border border-gray-200">
                        <div className="flex items-end justify-between mb-6">
                            <div>
                                <div className="text-sm text-gray-500 mb-1">YEAR</div>
                                <div className="text-5xl font-light tracking-tight">{selectedYear}</div>
                            </div>
                            <button
                                onClick={playTimeline}
                                disabled={isAnimating}
                                className="bg-black text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-gray-800 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                {isAnimating ? '재생 중' : '자동 재생'}
                            </button>
                        </div>
                        
                        <div className="mb-6 pb-6 border-b border-gray-200">
                            <div className="text-4xl font-light mb-1">{currentYearData?.total.toLocaleString()}</div>
                            <div className="text-sm text-gray-500">총 1인 가구 수</div>
                            <div className="mt-3 flex items-center gap-4 text-xs">
                                <div>
                                    <span className="text-gray-500">전체 가구 대비</span>
                                    <span className="ml-2 font-semibold text-black">{currentYearData?.ratio}%</span>
                                </div>
                                <div>
                                    <span className="text-gray-500">파티클</span>
                                    <span className="ml-2 font-semibold text-black">{totalParticles}개</span>
                                </div>
                            </div>
                        </div>

                        <div className="space-y-3">
                            <input
                                type="range"
                                min="0"
                                max={timelineData.length - 1}
                                value={timelineData.findIndex(d => d.year === selectedYear)}
                                onChange={(e) => handleYearChange(timelineData[parseInt(e.target.value)].year)}
                                className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                style={{ accentColor: '#000' }}
                            />
                            <div className="flex justify-between text-xs text-gray-500 font-medium">
                                <span>1990</span>
                                <span>2024</span>
                            </div>
                        </div>

                        {selectedYear > 1990 && (
                            <div className="mt-4 bg-gray-50 p-4 rounded-lg">
                                <div className="text-xs text-gray-500 mb-1">1990년 대비 증가율</div>
                                <div className="text-3xl font-light">
                                    +{Math.round((currentYearData.total / 257000 - 1) * 100)}%
                                </div>
                            </div>
                        )}
                    </div>

                    {/* 연령대별 리스트 */}
                    <div className="absolute right-8 bg-white rounded-2xl shadow-lg p-5 max-w-sm border border-gray-200" style={{ top: '484px' }}>
                        <h3 className="text-sm font-semibold mb-4 text-gray-700">연령대별 1인 가구 수</h3>
                        <div className="space-y-2 max-h-64 overflow-y-auto">
                            {currentAgeData.map((age) => (
                                <div 
                                    key={age.age}
                                    className="flex items-center justify-between text-sm p-3 rounded-lg hover:bg-gray-50 transition-all"
                                >
                                    <div className="flex items-center gap-2">
                                        <div 
                                            className="w-3 h-3 rounded-full flex-shrink-0"
                                            style={{ backgroundColor: `#${age.color.toString(16).padStart(6, '0')}` }}
                                        />
                                        <span className="font-medium text-gray-700">{age.age}</span>
                                    </div>
                                    <span className="font-mono text-xs text-gray-900 font-semibold">{age.count.toLocaleString()}</span>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* 주요 이유 */}
                    <div className="absolute bottom-8 left-8 bg-white rounded-2xl shadow-lg p-6 max-w-md border border-gray-200">
                        <h3 className="text-sm font-semibold mb-4 text-gray-700">1인 가구 주요 이유</h3>
                        <div className="space-y-3">
                            {reasonCategories.map((reason, i) => (
                                <div key={i}>
                                    <div className="flex justify-between text-sm mb-2">
                                        <span className="text-gray-700">{reason.name}</span>
                                        <span className="font-semibold text-black">{reason.percent}%</span>
                                    </div>
                                    <div className="w-full bg-gray-100 rounded-full h-2 overflow-hidden">
                                        <div 
                                            className="h-2 rounded-full transition-all"
                                            style={{ 
                                                width: `${reason.percent * 2.5}%`,
                                                backgroundColor: `#${reason.color.toString(16).padStart(6, '0')}`
                                            }}
                                        />
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* 컨트롤 */}
                    <div className="absolute bottom-8 right-8 bg-white rounded-2xl shadow-lg p-5 border border-gray-200">
                        <button
                            onClick={() => setIsRotating(!isRotating)}
                            className="w-full bg-black text-white px-5 py-3 rounded-lg text-sm font-medium hover:bg-gray-800 transition-all"
                        >
                            {isRotating ? '회전 정지' : '회전 시작'}
                        </button>
                        <div className="mt-3 text-xs text-gray-500 text-center">
                            클릭 앤 드래그로 시점 변경
                        </div>
                    </div>

                    {/* 인사이트 카드 */}
                    <div className="absolute left-8 bg-white rounded-2xl shadow-lg p-5 max-w-xs border border-gray-200" style={{ top: '274px' }}>
                        <h3 className="text-sm font-semibold mb-3 text-gray-700">핵심 인사이트</h3>
                        <div className="space-y-2 text-sm text-gray-600">
                            <div className="flex items-start gap-2">
                                <div className="w-1 h-1 bg-black rounded-full mt-2 flex-shrink-0"></div>
                                <div><span className="font-semibold text-black">1990→2024:</span> 6.5배 증가</div>
                            </div>
                            <div className="flex items-start gap-2">
                                <div className="w-1 h-1 bg-black rounded-full mt-2 flex-shrink-0"></div>
                                <div><span className="font-semibold text-black">최근 5년:</span> 연평균 7% 증가</div>
                            </div>
                            <div className="flex items-start gap-2">
                                <div className="w-1 h-1 bg-black rounded-full mt-2 flex-shrink-0"></div>
                                <div><span className="font-semibold text-black">2024년:</span> 서울 가구의 39.3%</div>
                            </div>
                        </div>
                    </div>

                    {/* 파티클 호버 툴팁 */}
                    {hoveredParticle && (
                        <div 
                            className="absolute bg-black text-white rounded-lg p-4 shadow-2xl pointer-events-none z-50"
                            style={{
                                left: `${tooltipPosition.x + 15}px`,
                                top: `${tooltipPosition.y - 15}px`,
                                transform: 'translateY(-100%)',
                                maxWidth: '250px'
                            }}
                        >
                            <div className="text-sm font-semibold mb-2 border-b border-white border-opacity-20 pb-2">
                                {hoveredParticle.age} 연령대
                            </div>
                            <div className="space-y-1 text-xs">
                                <div className="flex justify-between">
                                    <span className="text-gray-300">1인 가구 수:</span>
                                    <span className="font-semibold">{hoveredParticle.count.toLocaleString()}명</span>
                                </div>
                                <div className="flex justify-between">
                                    <span className="text-gray-300">전체 대비:</span>
                                    <span className="font-semibold">{hoveredParticle.ratio}%</span>
                                </div>
                            </div>
                            <div className="absolute top-full left-4 w-0 h-0 border-l-8 border-r-8 border-t-8 border-transparent border-t-black" style={{ transform: 'translateX(-50%)' }}></div>
                        </div>
                    )}
                </div>
            );
        };

        // Render the component
        ReactDOM.render(<SingleHouseholdVisualization />, document.getElementById('root'));
    </script>
</body>
</html>
